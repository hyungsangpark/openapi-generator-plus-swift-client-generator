import Foundation

struct OffsetDateTime: Codable {
    private static let regex = try! NSRegularExpression(pattern: "^(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})T(?:(?<hour>\\d*):)?(?:(?<minute>\\d*):)(?<second>\\d*\\.?\\d*)(?:(?<timezone>Z)|(?<timezoneOffset>[+-]\\d{2}:\\d{2}))?$", options: [])
    
    enum DecoderError: Error {
        case invalidMatch(value: String)
    }
    
    var year: Int
    var month: Int
    var day: Int
    var hour: Int
    var minute: Int
    var seconds: Double
    var timezone: TimeZone?
    
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let dateString = try container.decode(String.self)
        guard let matches = LocalDateTime.regex.matches(in: dateString, options: [], range: NSRange(dateString.startIndex..<dateString.endIndex, in: dateString)).first else {
            throw DecoderError.invalidMatch(value: dateString)
        }
        
        year = try matches.namedInt("year", in: dateString)
        month = try matches.namedInt("month", in: dateString)
        day = try matches.namedInt("day", in: dateString)
        hour = try matches.namedInt("hour", in: dateString)
        minute = try matches.namedInt("minute", in: dateString)
        seconds = try matches.namedDouble("second", in: dateString)
        
        if var timezoneString = try? matches.namedString("timezoneOffset", in: dateString) {
            let ordinal = timezoneString.removeFirst()
            let components = timezoneString.components(separatedBy: ":")
            let time = (Int(components[0])!*60 + Int(components[1])!) * 60
            if ordinal == "-" {
                timezone = TimeZone(secondsFromGMT: time * -1)!
            } else {
                timezone = TimeZone(secondsFromGMT: time)!
            }
        } else {
            timezone = nil
        }
    }
    
    var second: Int {
        Int(seconds)
    }
    
    var nanoSecond: Int {
        Int(seconds.truncatingRemainder(dividingBy: 1) * Double(NSEC_PER_SEC))
    }
    
    var dateComponents: DateComponents {
        return DateComponents(timeZone: timezone, hour: hour, minute: minute, second: second, nanosecond: nanoSecond)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        
        var dateStringComponents = [String]()
        
        dateStringComponents.append(String(format: "%04d", year))
        dateStringComponents.append(String(format: "%02d", month))
        dateStringComponents.append(String(format: "%02d", day))
        
        let dateString = dateStringComponents.joined(separator: "-")
        
        var timeStringComponents = [String]()
        
        timeStringComponents.append(String(format: "%02d", hour))
        timeStringComponents.append(String(format: "%02d", minute))
        timeStringComponents.append(String(format: "%02.3f", seconds))
        
        var timeString = timeStringComponents.joined(separator: ":")
        
        if let timezone = timezone {
            timeString += timezone.apiTimeZoneString
        } else {
            timeString += "Z"
        }
        
        try container.encode("\(dateString)T\(timeString)")
    }
}
