//  
//  {{>frag/generatedBy}}
//

import Foundation

public struct OffsetDateTime: Swift.Codable, Swift.Hashable, Swift.LosslessStringConvertible {
    private static let regex = try! Foundation.NSRegularExpression(pattern: "^([0-9]{4})-([0-9]{2})-([0-9]{2})T(?:(\\d*):)?(?:(\\d*):)(\\d*\\.?\\d*)(?:(?:Z)|([+-]\\d{2}:\\d{2}))?$", options: [])
    
    enum DecoderError: Error {
        case invalidMatch(value: String)
    }
    
    public var year: Int
    public var month: Int
    public var day: Int
    public var hour: Int
    public var minute: Int
    public var seconds: Double
    public var timezone: Foundation.TimeZone?
    
    public init(from decoder: Swift.Decoder) throws {
        let container = try decoder.singleValueContainer()
        let dateString = try container.decode(String.self)
        if let initialized = Self(dateString) {
            self = initialized
        } else {
            throw DecoderError.invalidMatch(value: dateString)
        }
    }

    public init?(_ description: String) {
        guard let matches = OffsetDateTime.regex.matches(in: description, options: [], range: Foundation.NSRange(description.startIndex..<description.endIndex, in: description)).first else {
            return nil
        }
        
        do {
            year = try matches.intAt(1, in: description)
            month = try matches.intAt(2, in: description)
            day = try matches.intAt(3, in: description)
            hour = try matches.intAt(4, in: description)
            minute = try matches.intAt(5, in: description)
            seconds = try matches.doubleAt(6, in: description)
            
            if var timezoneString = try? matches.stringAt(7, in: description) {
                let ordinal = timezoneString.removeFirst()
                let components = timezoneString.components(separatedBy: ":")
                let time = (Int(components[0])!*60 + Int(components[1])!) * 60
                if ordinal == "-" {
                    timezone = Foundation.TimeZone(secondsFromGMT: time * -1)!
                } else {
                    timezone = Foundation.TimeZone(secondsFromGMT: time)!
                }
            } else {
                timezone = nil
            }
        } catch {
            return nil
        }
    }
    
    var second: Int {
        Int(seconds)
    }
    
    var nanoSecond: Int {
        Int(seconds.truncatingRemainder(dividingBy: 1) * Double(NSEC_PER_SEC))
    }
    
    var dateComponents: Foundation.DateComponents {
        return Foundation.DateComponents(timeZone: timezone, hour: hour, minute: minute, second: second, nanosecond: nanoSecond)
    }
    
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(self.description)
    }

    public var description: String {
        var dateStringComponents = [String]()
        
        dateStringComponents.append(String(format: "%04d", year))
        dateStringComponents.append(String(format: "%02d", month))
        dateStringComponents.append(String(format: "%02d", day))
        
        let dateString = dateStringComponents.joined(separator: "-")
        
        var timeStringComponents = [String]()
        
        timeStringComponents.append(String(format: "%02d", hour))
        timeStringComponents.append(String(format: "%02d", minute))
        timeStringComponents.append(String(format: "%02.3f", seconds))
        
        var timeString = timeStringComponents.joined(separator: ":")
        
        if let timezone = timezone {
            timeString += timezone.apiTimeZoneString
        } else {
            timeString += "Z"
        }
        
        return "\(dateString)T\(timeString)"
    }
}
