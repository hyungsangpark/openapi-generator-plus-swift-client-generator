import Foundation

struct LocalTime: Codable {
    
    private static let regex = try! NSRegularExpression(pattern: "^(?:(?<hour>\\d*):)?(?:(?<minute>\\d*):)(?<second>\\d*\\.?\\d*)$", options: [])
    
    enum DecoderError: Error {
        case invalidMatch(value: String)
    }
    
    var hour: Int?
    var minute: Int
    var seconds: Double
        
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let dateString = try container.decode(String.self)
        guard let matches = LocalTime.regex.matches(in: dateString, options: [], range: NSRange(dateString.startIndex..<dateString.endIndex, in: dateString)).first else {
            throw DecoderError.invalidMatch(value: dateString)
        }
        hour = try? matches.namedInt("hour", in: dateString)
        minute = try matches.namedInt("minute", in: dateString)
        seconds = try matches.namedDouble("second", in: dateString)
        
    }
    
    var second: Int {
        Int(seconds)
    }
    
    var nanoSecond: Int {
        Int(seconds.truncatingRemainder(dividingBy: 1) * Double(NSEC_PER_SEC))
    }
    
    var dateComponents: DateComponents {
        return DateComponents(timeZone: timezone, hour: hour, minute: minute, second: second, nanosecond: nanoSecond)
    }
        
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        var timeStringComponents = [String]()
        
        if let hour = hour {
            timeStringComponents.append(String(format: "%02d", hour))
        }
        timeStringComponents.append(String(format: "%02d", minute))
        timeStringComponents.append(String(format: "%02.3f", seconds))
        
        try container.encode(timeStringComponents.joined(separator: ":"))
    }
}